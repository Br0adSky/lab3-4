package org.nsu.fit.services.rest;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.github.javafaker.Faker;
import com.github.javafaker.Name;
import org.glassfish.jersey.client.ClientConfig;
import org.nsu.fit.services.log.Logger;
import org.nsu.fit.services.rest.data.*;
import org.nsu.fit.shared.JsonMapper;

import javax.ws.rs.BadRequestException;
import javax.ws.rs.client.*;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.stream.Collectors;

public class RestClient {
    // Note: change url if you want to use the docker compose.
//    private static final String REST_URI = "http://localhost:8080/tm-backend/rest";
    private static final String REST_URI = "http://localhost:8089/tm-backend/rest";

    private final static Client client = ClientBuilder.newClient(new ClientConfig().register(RestClientLogFilter.class));

    public CustomerPojo autoGenerateCustomer(){
        CustomerPojo customer = new CustomerPojo();
        Name name = new Faker().name();
        // Лабораторная 3: Добавить обработку генерацию фейковых имен, фамилий и логинов.
        // * Исследовать этот вопрос более детально, возможно прикрутить специальную библиотеку для генерации фейковых данных.
        customer.firstName = name.firstName();
        customer.lastName = name.lastName();
        customer.login = String.format("%s%s@mail.com", customer.firstName.toLowerCase(), customer.lastName.toLowerCase());
        customer.pass = "strongpass";
        return customer;
    }

    public AccountTokenPojo authenticate(String login, String pass) {
        CredentialsPojo credentialsPojo = new CredentialsPojo();

        credentialsPojo.login = login;
        credentialsPojo.pass = pass;

        return post("authenticate", JsonMapper.toJson(credentialsPojo, true), AccountTokenPojo.class, null);
    }

    public CustomerPojo createAutoGeneratedCustomer(AccountTokenPojo accountToken) {
        ContactPojo contactPojo = autoGenerateCustomer();

        // Лабораторная 3: Добавить обработку генерацию фейковых имен, фамилий и логинов.
        // * Исследовать этот вопрос более детально, возможно прикрутить специальную библиотеку для генерации фейковых данных.

        return post("customers", JsonMapper.toJson(contactPojo, true), CustomerPojo.class, accountToken);
    }

    public TopUpBalancePojo fillTopUpBalancePojo(CustomerPojo customerPojo){
        TopUpBalancePojo top = new TopUpBalancePojo();
        top.customerId = customerPojo.id;
        top.money = 500;
        return top;
    }

    public void topUpBalance(AccountTokenPojo accountTokenPojo, TopUpBalancePojo top){
        post("customers/top_up_balance", JsonMapper.toJson(top, true), null, accountTokenPojo);
    }

    public PlanPojo fillValidPlan(){
        PlanPojo planPojo = new PlanPojo();
        planPojo.details = "Good description";
        planPojo.fee = 500;
        planPojo.name = "plan on 500$";
        return planPojo;
    }

    public PlanPojo createPlan(AccountTokenPojo accountTokenPojo) {
        PlanPojo planPojo = fillValidPlan();
        return post("plans", JsonMapper.toJson(planPojo, true), PlanPojo.class, accountTokenPojo);
    }

    public void deletePlan(AccountTokenPojo accountTokenPojo, PlanPojo planPojo) {
        delete("plans", planPojo.id.toString(), accountTokenPojo);
    }

    public PlanPojo createUnValidPlan(AccountTokenPojo accountToken, PlanPojo planPojo) {
        return post("plans", JsonMapper.toJson(planPojo, true), PlanPojo.class, accountToken);
    }

    private static void delete(String path, String body, AccountTokenPojo accountToken) {
        Invocation.Builder request = client
                .target(REST_URI)
                .path(String.format("%s/%s", path, body))
                .request(MediaType.APPLICATION_JSON)
                .accept(MediaType.APPLICATION_JSON);

        if (accountToken != null) {
            request.header("Authorization", "Bearer " + accountToken.token);
        }
        Response response;
        try {
            response = request.delete();
            Logger.info(String.format("The Response status: %s", response.getStatus()));
            Logger.info("Object deleted");
        } catch (Exception exception) {
            Logger.error("Exception was thrown:", exception);
            throw exception;
        }
    }

    public CustomerPojo me(AccountTokenPojo accountTokenPojo) {
        return get("me", accountTokenPojo, false, CustomerPojo.class);
    }

    public List<CustomerPojo> getCustomers(AccountTokenPojo accountTokenPojo) {
        List<LinkedHashMap<String, String>> list = get("customers", accountTokenPojo, true, null);
        final ObjectMapper mapper = new ObjectMapper();
        return list.stream().map(stringStringLinkedHashMap -> mapper.convertValue(stringStringLinkedHashMap, CustomerPojo.class)).collect(Collectors.toList());
    }

    private static <R> R get(String path, AccountTokenPojo accountToken, boolean isList, Class<R> responseType) {
        Invocation.Builder request = client
                .target(REST_URI)
                .path(path)
                .request(MediaType.APPLICATION_JSON)
                .accept(MediaType.APPLICATION_JSON);

        if (accountToken != null) {
            request.header("Authorization", "Bearer " + accountToken.token);
        }
        String response = "";
        try {
            response = request.get(String.class);
            Logger.info(String.format("The Response: %s", response));
        } catch (Exception exception) {
            Logger.error("Exception was thrown:", exception);
            throw exception;
        }
        if (isList) {
            return JsonMapper.fromGenericJson(response);
        }
        return JsonMapper.fromJson(response, responseType);

    }



    private static <R> R post(String path, String body, Class<R> responseType, AccountTokenPojo accountToken) {
        // Лабораторная 3: Добавить обработку Responses и Errors. Выводите их в лог.
        // Подумайте почему в filter нет Response чтобы можно было удобно его сохранить.
        Invocation.Builder request = client
                .target(REST_URI)
                .path(path)
                .request(MediaType.APPLICATION_JSON)
                .accept(MediaType.APPLICATION_JSON);

        if (accountToken != null) {
            request.header("Authorization", "Bearer " + accountToken.token);
        }

        if(responseType == null){
            try{
                Response response = request.post(Entity.entity(body, MediaType.APPLICATION_JSON));
                if(response.getStatus() == 400)
                    throw new BadRequestException();
                Logger.info(String.format("The Response status: %s", response.getStatus()));
                return null;
            } catch (BadRequestException exception) {
                Logger.error("Exception was thrown:", exception);
                throw exception;
            }
        }
        Response response;
        String responseDTO = "";
        try {
            response = request.post(Entity.entity(body, MediaType.APPLICATION_JSON));
            responseDTO = response.readEntity(String.class);
            if(response.getStatus() == 400)
                throw new BadRequestException();
            Logger.info(String.format("The Response: %s", responseDTO));
        } catch (BadRequestException exception) {
            Logger.error("Exception was thrown:", exception);
            throw exception;
        }

        return JsonMapper.fromJson(responseDTO, responseType);
    }

    public void createUnValidCustomer(AccountTokenPojo adminToken, CustomerPojo customer) {
        post("customers", JsonMapper.toJson(customer, true), CustomerPojo.class, adminToken);
    }

    public List<PlanPojo> getPlans(AccountTokenPojo adminToken) {
        List<LinkedHashMap<String, String>> list = get("customers", adminToken, true, null);
        final ObjectMapper mapper = new ObjectMapper();
        return list.stream().map(stringStringLinkedHashMap -> mapper.convertValue(stringStringLinkedHashMap, PlanPojo.class)).collect(Collectors.toList());

    }

    private static class RestClientLogFilter implements ClientRequestFilter {
        @Override
        public void filter(ClientRequestContext requestContext) {
            try {
                Logger.debug(requestContext.getEntity().toString());
            } catch (NullPointerException exception) {
                Logger.debug("OK");
            } catch (Exception exception) {
                Logger.error(exception.getMessage());
            }

            Logger.info(requestContext.getMethod());
            Logger.info(requestContext.getStringHeaders().keySet().toString());

            // Лабораторная 3: разобраться как работает данный фильтр
            // и добавить логирование METHOD и HEADERS.
        }
    }
}
